# **PA 3-3 解题报告**

##### 刘泓尊   2018011446   计84

### 一、数据结构与算法构思

#### 1.三个数组求和第k小

#### **1.1 思路来源**

​		根据本题提示，可以从一个数组求第k小切入。结合优先级队列的提示：对于一个数组，我们可以维护一个size = k的最小堆，先对数据进行排序，每次检测的数据是递增的，那么我们可以每次push进一个元素，pop堆顶两个元素，进行k - 1次之后堆顶就是第k小。针对三维数据的方法，也是如此。

#### **1.2 获得的帮助**

​		1.对于数组排序的方法：我一开始认为固定两个数对第三个数排序可能不是最优解法，但是和课程小助教董博文交流之后，他肯定了我的做法。

​		2.堆的上滤下滤方式十分经典，参考了课堂讲义12-B2;

#### **1.3 思路**

**1.3.1 基本思路——维护最小堆**

​		由于原始数据不可访问，我设置了 三个rank数组，记录x,y,z排序之后其原始rank在新数组中的位置，即rankx, ranky, rankz.由此可以得到一个三维的图（不仿想象为立方体）。

​		该立方体体现的是排序之后的rank，(x,y,z)自小到大其对应和依次递增。即：
$$
sum(rankx[x_1], ranky[y_1], rankz[z_1]) <\\ sum(rankx[x_2], ranky[y_2], rankz[z_2]),\\
when \quad x_1<=x_2\quad\&\quad y_1 <= y_2\quad\&\\z_1<=z_2\quad\&\quad(x_1,y_1,z_1)!=(x_2,y_2,z_2)
$$
​		因此只需要每次取出堆顶元素，然后加入堆顶元素相邻的但比它大的三个元素，直到pop()出k个元素为止，此时堆顶元素就是第k小。

**1.3.2 冲突的解决**

​		仔细分析push过程可以发现，可能存在节点被重复push()，因此需要保证立方体中每个节点的**入度为1**，所以我们维护一个单向的路径：

```
1.在(x,y,z) = (x,1,1)时，取出比它大的三个方向的点加入堆。
2.在(x,y,z) = (x,y,1)时，取出 y,z两个方向 +1 的点加入堆
3.在其他情况下，只将 z+1 之后加入堆
```

### 三、时间和空间复杂度估算

##### **1. 时间复杂度**

​		数据预排序需要O(3nlogn)的复杂度，之后维护大小为k的最小堆，共o(k)次插入，每次插入最坏O(logk),因此O(klogk)
$$
T(n) = O(nlogn + klogk)
$$

**2. 空间复杂度**

​		使用三个rank数组标记排序之后的rank,然后维护了size = k的最小堆，总空间复杂度：

$$
S(n) = O(3n + k) = O(n+k)
$$

