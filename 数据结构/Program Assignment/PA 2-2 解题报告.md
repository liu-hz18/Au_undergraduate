# **PA 2-2 解题报告**

##### 刘泓尊   2018011446   计84

### 一、数据结构与算法构思

#### 1.数据结构——01字典树

##### **1.1 思路来源**

​		由于本题只有01两个值，所以想到可以对应二叉树中左右两个分支，向左为0向右为1，这和字典树十分类似。其次由于本题的空间限制，我采用动态开点策略维护字典树。在物理上，树节点和队列节点采用相同的形式。

##### **1.2 获得的帮助**

​		关于相同的原件如何在字典中存储的问题，我曾向董博文小助教询问此问题。他提醒我可以在叶子节点里存储一个队列，维护重复的原件的rank。在删除的时候删除队首即可。问询的时候则直接取队首。

##### **1.3 算法思路**

​		求取异或值最大原件，只需要在[n - k,n + k]个原件构成的01字典树中找到对应的路径。具体做法为：

​		首先将[n - k,n + k]范围内的元件插入字典树，如果0则向左构建，否则向右构建。注意**超过此范围的元件应该从字典树中删除**。

​		对于每个问询，由于要寻找异或值最大的元件，显然高位不同能实现更大的异或值。所以当对应位为1时，就向左(0)的方向寻路，否则向右。当路径不存在时才向相同的一侧走。走到叶子节点时，获得该路径对应元件的id.

​		如果叶子节点是一个队列，则由于靠前的元件先被插入，所以结果不是在队列的第一个就是在队列的第二个。返回结果即可。

### **二、过程中遇到的问题及解决**

##### 1. 重复元件的处理	

```C++
相同的原件如何在字典中存储的问题，我曾向董博文小助教询问此问题。
他提醒我可以在叶子节点里存储一个队列，维护重复的原件的rank。在删除的时候删除队首即可。问询的时候则直接取队首。
```

### **三、时间和空间复杂度估算**

##### **1. 时间复杂度**

​		字典树的插入、删除操作都是O(log depth) = O(log 64) 的。总共n次插入删除，复杂度O(6n)  = O(n)

$$
T(n) = O(log64*n) = O(n)
$$

##### **2. 空间复杂度**

​	插入一个节点最多用空间64个，最坏情况下第k层有n个节点时，其后全为链状，所以总空间为

$$
S(n) = O(n*(64 - k) + 2^k - 1) = O(n)
$$

