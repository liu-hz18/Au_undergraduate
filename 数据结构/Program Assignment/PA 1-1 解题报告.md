# **PA 1-1 解题报告**

##### 刘泓尊   2018011446   计84

### 一、数据结构与算法构思

#### 1.算法——压位

##### **1.1 思路来源**

​		一开始我使用FFT写的本题，但是实测发现FFT尽管复杂度低，但是却存在很大的常数。看到课程微信群中同学们也在讨论“压位 算法快于FFT”的现象，我最终决定采用压位。

##### **1.2 参考资料**

​		1.课程微信群中对于 压位算法 的讨论。

​		2.printf输出格式控制方法学习于https://www.cnblogs.com/unknownname/p/9377536.html

##### **1.3 算法思路**

​		压位算法的本质是模拟手算乘法，只不过手算的时候是“十进制”的，但是由于64位计算机计算64位以下的乘法只需要1-3个时钟周期，实际上可以让计算机一次处理多位乘法，其单次乘法的速度几乎不变，然而做乘法的总次数却大大减少，因此可以达到节省时间的效果。

**1.3.1 数据预处理**

​		在以字符串形式读入乘数之后，我将其从高位自低位，每8位作为一个区间，将这个区间内的字符串转换为整数，自低向高存入numa,numb数组。为了保证相乘之后数字不溢出，numa,numb以及结果数组numc都采用long long存储。**注意，对于数字的最高位，有可能不足8位，所以在到达最高位区间内时，应当进行特殊处理**。

**1.3.2 乘法与进位**

​		由于numa,numb的数字时自低向高存储的，所以只需要自低向高对numa,numb进行二重循环遍历，得到：
$$
numc[i+j] = \sum {numa[i]*numb[j]}
$$
​		上式本质上是**卷积**运算。在运算完每一位之后，进行进位处理，超过1e8则进位。

**1.3.3 输出结果**

​		在进位处理之后，每一个numc元素的长度都是小于等于8的，根据乘法的计算原理，直接将其从高位向低位输出即可。**注意最高位不足8位时输出实际位数，其他位不足8位时输出应补0**！

### **二、过程中遇到的问题及解决**

##### 1. 输出结果首位有0，应该去除	

```C++
在最初的版本中，我的输出由于没有考虑到存在不满8位的情况而出错。
一定注意在输出时，最高位不足8位时输出实际位数，其他位不足8位时输出应补0，并且是右对齐的。
可以通过printf的格式控制实现，即printf("%08ld", numc[i]);
```

### **三、时间和空间复杂度估算**

##### **1. 时间复杂度**

​		由于我选择压8位，所以在乘法运算上实际上是O(n^2/64)的，在数据的输入输出上均为O(n),设有m组数据，则时间复杂度：

$$
T(n) = m(O(\frac{n^2}{64}) + 2O(n)) = O(m\times\frac{n^2}{64})
$$

##### **2. 空间复杂度**

​		设输入数据对数为m,数字长度的最大值为n，输入字符串为O(2n),在程序中总共有3个数组分别存储了输入字符串转化为压位数组的结果和计算结果，每组数据空间开销O(5n),故空间复杂度为:

$$
S(n) = O(m*(n*5)) = O(mn)
$$

