# PA 1-3 解题报告

#### 刘泓尊  2018011446	计84

### 一、数据结构与算法构思

#### 	1.思路来源

​		由于本题要求“最小修改次数”，并且决策可以分步进行，因此本题可以使用**动态规划**解决。

#### 	2.参考资料

​		1.对于两字符串最小编辑次数的求解，我参考了“数据结构”讲义**LCS**部分动态规划的思路，形成正确思路之后，在https://www.cnblogs.com/boris1221/p/9375047.html上得到了验证。

​		2.我一开始使用O(n^2)的时间复杂度，使得本题测例超时，经过看到"课程微信群"中 **"刘润达" 小助教**与他人的讨论之后，我得到了启发，实现了 **O(nk)** 的复杂度。

#### 	3.算法思路

$$
设dp[i][j]为字符串s1[1:i]和字符串s2[1:j]的最小编辑次数，那么dp[i][j]可以递归地进行求解：
$$


$$
dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1]+2)
$$
​	其中:
$$
dp[i - 1][j] + 1表示s1添加一个元素之后的最小操作数；\\

dp[i][j - 1] + 1表示s1删除一个元素之后的最小操作数；\\

dp[i - 1][j - 1] + 2表示将s1第i个元素替换为第j个元素的最小操作数，\\其中替换操作的代价为2（先删除后添加）；
$$


#### 4.算法优化 

1. ##### 空间优化

​		经过独立的思考，由于动态规划过程中每一步只使用到了dp\[i]\[j],dp\[i - 1]\[j],dp\[i]\[j - 1],dp\[i - 1]\[j - 1],实际上每次只使用了dp\[]\[]矩阵中的两行，因此只需标记当前使用的两行。使用current变量标记，每次将变量current换为1 - current.

​		在状态转移过程中，如果s1[i - 1] == s2[j - 1]，则dp\[current][j] = dp\[1 - current][j - 1]；

否则dp\[current][j] = min(dp\[1 - current][j], dp\[current][j - 1], dp\[1 - current][j - 1] + 1, K) + 1

2. ##### 时间优化

​		直接对所有i,j 进行求解显然需要O(n^2)的复杂度。但考虑到本题的限制条件，大于K之后输出-1，实际上只需要对
$$
(i,j) = (i,[i - k,i + k])
$$
的范围进行计算，超过此范围的dp\[i]\[j]代价均超过了K(因为相差了K位以上)。所以时间复杂度可以降低为O(n*(2k + 1)) = O(nk)。相当于只对一个"斜对角"区域进行计算。

### 二、过程中遇到的问题与解决

####    1.时间复杂度过高导致超时

​		我一开始使用O(n^2)的时间复杂度，使得本题测例超时。经过看到"课程微信群"中 "刘润达" 同学与他人的讨论之后，我得到了启发，实现了 O(nk) 的复杂度。具体实现思路见**“时间优化”**部分。

### 三、时间和空间复杂度估算

#### 	1.时间复杂度

​		考虑到本题的限制条件，大于K之后输出-1，实际上只需要对(i,j) = (i,[i - k,i + k])的范围进行计算，超过此范围的dp\[i]\[j]代价均超过了K(因为相差了K位以上)。所以时间复杂度可以降低为
$$
O(n*(2k + 1)) = O(nk)
$$

#### 	2.空间复杂度

​		经过独立的思考，由于动态规划过程中每一步只使用到了dp\[i]\[j],dp\[i - 1]\[j],dp\[i]\[j - 1],dp\[i - 1]\[j - 1],实际上每次只使用了dp\[]\[]矩阵中的两行，因此只需标记当前使用的两行。空间复杂度为：
$$
O(2n) = O(n)
$$
