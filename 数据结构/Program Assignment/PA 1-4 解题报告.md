# PA 1-4 解题报告

#### 刘泓尊  2018011446  计84

### 一、数据结构与算法构思

#### 1.思路来源

​		由于本题依然求解最优问题，所以切入点依然使用动态规划。由于问题是单自由度（一维）问题，所以只需要建立一维的动态规划数组。

#### 2.参考资料

​	1.**PA 提示**中使用“单调队列“优化

​	2.对于单调队列的实现，我一开始采用自前向后的方式，但限于dp[j]无法预知，此思路未能实现.对于此问题,我请教了课堂**小助教“董博文”,**他建议我 自后向前 扫描dp,解决了该问题!

​	3.关于队列的实现，我 复现 了学习OOP时自己写的Queue模板(并未公开)，并非照搬代码。

#### 3.算法思路

​	1.动态规划思路

​		对于每一步决策，可以考虑其前的所有可以到达该点的决策，选择之前成本最小的点进行连接。设dp[i]为走到第i个位置的最优用时，则状态转移方程可以用公式表达为：
$$
dp[i] = min(dp[j] + t[j])\quad when \quad l[j] <= i <= r[j]
$$
​	2.单调队列优化

​		由于在决策过程中，状态转移方程是求解最小值的，所以可以采用**单调队列优化时间复杂度**。具体思路为：

​		a.自后向前求解dp[i],**边界条件**设为
$$
dp[n] = 0
$$
输出结果为dp[1].

​		b.对于每一个dp[i]位置的决策，其最优下一步一定是选择**l[i]到r[i]中dp[j]最小的j** 来进行转移。

对于单调队列来说，只需要将dp[j]最小的j放入队列头，每次取出队列头就可以获得最优子决策。

​		c.在每次加入队列时，应考虑到该点是不是“**可达的**”，即**每次将[l[i],l[i + 1])的点i加入 队列**，同时**将(r[i], r[i + 1]]的位置i 弹出队列头**（因为先加入的元素一定 最有机会不可达）。对于队列尾部每一个**不是最优解的点，将其弹出队列尾**。实际上，本题应写出一个支持队头队尾都可弹出的“伪双端队列”。

### 二、过程中遇到的问题与解决

####  1. 动态规划未使用单调队列优化，导致超时。

​		在一开始的版本中，我未使用单调队列优化，仅仅采用了上面“动态规划思路”的未优化版本，时间复杂度为O(n^2)，使得时间超时。当时的代码思路为：

```
对于每一个位置 i , 从0到i寻找 dp[i] + t[i] 最小的 i,则从 i 到 j 的跳跃是单步最优解，进行状态转移。 因为复杂度过高，本暴力算法是超时的。
```

​		对于优化的建模问题,一开始我采用了自前向后的方式，但限于dp[j]无法预知，此思路未能实现。因此，我请教了课堂小助教“董博文”,他建议我 自后向前 扫描dp,解决了该问题!具体思路见“单调队列优化部分”。详细思路如下：

```
注意到l[i],r[i]的单调性，即区间的单调覆盖性，能跳到第i个位置的j一定处于连续的集合中。并且j<i。所以我们从后向前扫描每一个位置i，将不在队列中的“该步可达点”加入队列 ，即 将[l[i], min(l[i + 1], r[i] + 1))的元素加入队列。
在将每个元素加入时，为了维护队列的单调递减性，将队列中dp值大于dp[j]的元素弹出，再将此元素入队。
同时在向前扫描过程中，由于队列头是最先加入的，所以最有可能成为“该步不可达点”，所以要将大于r[i]的点出队。
综上，本题维护了一个dp值单调递减的双端队列，支持从队尾加入 以及 队尾队头出队。实现了一次遍历就可以得到每个点的dp值。
```



### 三、复杂度估计

#### 1.时间复杂度

​		对于单调队列优化后的动规，由于**每个点最多出队入队一次**，因此时间复杂度为:
$$
O(n)
$$

#### 2.空间复杂度    

​		在程序中总共建立了**t[n],l[n],r[n],dp[n]**四个一维数组，空间复杂度为:
$$
O(n)
$$
