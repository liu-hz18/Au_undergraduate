# **PA 1-1 解题报告**

##### 刘泓尊   2018011446   计84

### 一、数据结构与算法构思

#### 1.算法——FFT（快速傅里叶变换）

##### **1.1 思路来源**

​		由于之前没有接触过OI，本题使用**FFT**的想法来自于**微信群**中同学们的讨论。在群中，**董博文**小助教提到了使用**FFT**方法的速度将快于压位，所以我决定使用**FFT**解决本问题。

##### **1.2 参考资料**

​		本人之前未曾学习过**FFT**，因此**FFT**的思路是从**网络上学习**的。学习资源有 <https://www.cnblogs.com/RabbitHu/p/FFT.html>，

<https://www.luogu.org/blog/command-block/fft-xue-xi-bi-ji>

​		但本人只学习了算法的**思路**，算法的实现是由本人自己完成，并未借鉴网上的**代码**。

##### **1.3 算法思路**

​		FFT是处理多项式乘法的快速算法，主要思路是将多项式的“**系数表示**”转化为“**点值表示**”，通过点值表示相乘得到计算结果的“点值表示”，最后通过傅里叶逆变换得到系数表示。

​		FFT相比于DFT，是**利用了单位根的性质**来降低复杂度。原理如下：

​	设*A*(*x*)=*a*0+*a*1*x*+*a*2*x*2+...+*an*−1*xn*−1，把单位根*x*=ω^k_n代入，并将*A*(*x*)的每一项按照下标的奇偶分成两部分，

$$
A(x)=(a_0+a_2x^2+...+a_{n−2}x^{n−2})+(a_1x^1+a_3x^3+...+a_{n−1}x^{n−1})
$$
​	设两个多项式：
$$
A_1(x)=a_0+a_2x^2+...+a_{n−2}x^{n-2}，A_2(x)=a_1+a_3x^3+...+a_{n−1}*x^{n−1}
$$
​	则，

$$
A(x)=A_1(x^2)+xA_2(x^2)
$$
​	假设k<n/2，把x=ω^k_n代入得，
$$
A(ω^k_n)=A_1({ω^k_n}^2)+ω^k_nA_2({ω^k_n}^2)=A_1({ω^k_n}^2)+ω^k_nA_2({ω^k_n}^2)
$$
​	对于*A*(*ωk*+*n*2*n*)，

$$
A(ω^{k+n/2}_n)=A_1(ω^{2k+n}_n)+ω^{k+n/2}_nA_2(ω^{2k+n}_n)\\

=A_1(ω^{2k}_nω^n_n)+ω^{k+n/2}_nA2(ω^{2k}_nω^n_n)\\

=A_1(ω^k_{n/2})−ω^k_nA_2(ω^k_{n/2})
$$
​	所以，如果知道两个多项式*A*1(*x*)和*A*2(*x*)分别在
$$
(ω^0_{n/2},ω^1_{n/2},ω^2_{n/2},...,ω^{n/2-1}_{n/2})
$$
​	的点值表示，就可以*O*(*n*)求出*A*(*x*)在
$$
ω^0_n,ω^1_n,ω^2_n,...,ω^{n−1}_n
$$
​	处的点值表示了。而A_1(x)和A_2(x)都是规模缩小了一半的子问题，所以可以采用分治算法解决

(参考资料：<https://www.cnblogs.com/RabbitHu/p/FFT.html>)

##### **1.4 算法优化**

​		基于递归法的**FFT**受限于速度与栈空间大小，因此寻找非递归解法的**FFT**很有必要。通过对递归的跟踪可以发现，递归底层的数组下标与初始下标关系为：递归底层数组下标为初始下标的**二进制位反转**。（如图1）

![1570009279192](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1570009279192.png)

​                        图1（图源<https://www.luogu.org/blog/command-block/fft-xue-xi-bi-ji>）

​		依据上述思路，**将整数的每一位看做多项式每一项的系数**，多项式的x取10即可实现转化与应用，进而可以快速实现高精度乘法。

### **二、过程中遇到的问题及解决**

##### 1. 输出结果首位有0，应该去除

​		由于次高位有时不会进位，所以最高位有可能出现为0.对于此问题，我经过与**董博文**交流之后，我在void transToResult()函数中添加了如下思路，解决了该问题。

```
//防止首位为0的情况出现，一开始我的程序出现了此问题，经过向 董博文 请教之后，我对result做了如下的处理。
从结果的最后一个位置向前扫描，将为零的位去除（实际的操作为将len--），这样就可以解决高位输出0的问题。由于高位的0是小于3的，所以本操作是常数时间完成的。
```



##### 2. **位元反转的复杂度优化**

​		对于位元反转，我一开始采用了如下思路：

```
从前向后遍历二进制位，将数字的第j个二进制为进行对称交换，进而实现位元反转。
```

​		在最终的版本中，我参考了<https://www.luogu.org/blog/command-block/fft-xue-xi-bi-ji>的思路，代码如下：

```
//位反转处理思路来自于博客 https://www.luogu.org/blog/command-block/fft-xue-xi-bi-ji
对于每一个数，其反转等于将最后一位移到第一位，同时将剩下的数位反转放到后面。
剩下数位的反转等于reverse[i >> 1] >> 1
最后一位反转到 第一位需要 | ((i & 1) << (codelen - 1))
所以可以在O(n)时间内实现数位的反转。
```

### **三、时间和空间复杂度估算**

##### **1. 时间复杂度**

​		由于FFT采用分治策略，设T(n)为所用时间，则T(n)= 2T(n/2)+O(n) = O(n\*lgn)

时间复杂度：

$$
T(n) = 3  O(nlogn) + O(n) = O(nlogn)
$$

##### **2. 空间复杂度**

​		设输入数据对数为m,数字长度的最大值为n，则空间复杂度：

$$
S(n) = O(m*(n*2)*3) = O(mn)
$$

