# **PA 3-1 解题报告**

##### 刘泓尊   2018011446   计84

### 一、数据结构与算法构思

#### 1.字符串匹配

#### **1.1 思路来源**

​	【PA3-1提示】考虑到本题的特点，数据只有0/1两种情况，因此采用Bitset存储数据，节省空间。同时采纳了提示中“枚举匹配”的方式。

#### **1.2 获得的帮助**

1.Bitmap数据结构：课程讲义02-XA1的代码是十分高效的，因此我采用了课程讲义里的方式。

#### **1.3 思路**

​		首先用Bitset存储01串,长度为n.

**1.3.1** 可以证明，**结果的长度不超过log(n)**:

​		如果长度为k的字符串在原始字符串中全部出现，则原始数据至少应该有2^k  + k - 1的长度。即n>= 2^k + k - 1.因此，如果原始字符串的长度为n，则结果长度的上限为log(n).

**1.3.2** 基于答案的特点，可以设计出**o(nlogn)的“朴素”算法**

​		从0-log(n)枚举每一个长度，对于每一个长度len,有2^len中排列。在原始串中寻找长度为len的子串，将出现的每个排列都标记下来。一趟扫描完成的时候，如果某一个排列没有出现，则这个排列就是字典序最小的 未出现子串。 

### 三、时间和空间复杂度估算

##### **1. 时间复杂度**

​		 结果长度不超过log(n)，对于长度为len的扫描，最多将整个字符串遍历一遍，为O(n), 所以时间复杂度为：
$$
T(n) = O(nlogn)
$$

**2. 空间复杂度**

​		使用Bitset存储原始字符串，空间开销 O(n/8) = O(n) ,为每个出现的 字符串做标记最多花费 O(2^logn) = O(n) 的空间，所以空间复杂度为：

$$
S(n) = O(n)
$$

