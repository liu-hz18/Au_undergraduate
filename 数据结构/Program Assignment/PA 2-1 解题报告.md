# **PA 2-1 解题报告**

##### 刘泓尊   2018011446   计84

### 一、数据结构与算法构思

#### 1.数据结构——基于邻接链表的多叉树

#### **1.1 思路来源**

​	因为本题要求所有操作的复杂度在cost范围内，基于cost的特点，其表示了路径深度及所有孩子“兄长”的个数，所以自然想到使用类似邻接表的结构，每次找到一层内的节点就跳转到对应的子节点链表中。为减少空间开销，且使得插入、删除都是o(1)的，我采用邻接链表（双向链表）（文件中ChildList.h中ChildList类）实现。为了避免遍历所有子树，我维护了后缀最大高度。

#### **1.2 获得的帮助**

​		我的最初版本中，我没有充分理解题意，认为多叉树的节点自上而下是递增的，因此我采用一次循环倒序建树导致出错。之后是刘云昊同学提醒了我这个问题，在此向他表示感谢！

#### **1.3 思路**

##### **1.3.1建树思路**

​	我先将所有数据读入，之后根据每层的节点数量建立邻接链表，过程与输入的数字是完全对应的，数据结构在拓扑关系上也与输入数据完全相同。在第一遍建树时初始化id,同时插入顺序也保证了rank和输入是对应的。由此，完成了拓扑结构的初始化。

​	对于子树的高度、大小、后缀最大高度的初始化，我采用递归的方式。为了保证每次插入删除都避免重新计算子树高度，我维护了每个子树的后缀最大高度。因此在建树时，自顶向下进行递归，每次从某个节点孩子链表中倒序建立子树，这样就可以在建立前一个子树时可以知道其后兄弟的高度，于是后缀最大高度得以建立。

​	此外，一个重要的细节就是当某个孩子是其孩子链表中最后一个节点时，其后缀最大高度设为-1，随后我们将看到这将带来方便。

​	对应于代码中initTree()函数和initinfo()函数。

##### **1.3.1 删除思路**

​		由于插入时并不知道一路上的节点要更新多少，所以应先沿路径找到节点。之后进行删除后的更新操作，首先改变在其前面的兄弟节点的后缀最大高度，其次沿着来时的路径向上更新祖先的高度，在更新祖先高度的同时，也应改变祖先兄弟中在其之前的后缀最大高度。因此一次向下寻路，一次逆序修改，o(2 cost)。在更新完成后，改变被删除节点在物理上的连接关系。插入时的路径为删除节点之后的新路径。

​	对应于代码中的update_del() 函数。

##### **1.3.2 插入思路**

​		同样依照删除时查找的方法找到待插入位置，插入之前删除的节点，然后依照同样的过程，依次更新

```
1.兄弟节点的 后缀最大高度
2.祖先的 高度、后缀最大高度、子树大小
3.祖先之前的兄弟的 后缀最大高度
```

​	复杂符o(2 cost)对应于代码中的update_above()函数。

##### **1.3.3 问询思路**

​	因为在删除、插入过程中都更新了高度、大小和后缀最大高度，所以问询便十分简单，沿着问询路径查询即可。

### **二、过程中遇到的问题及解决**

##### 1. 没有理解路径中最后一个合法节点

```C++
  最初我查询目标节点的方式为，一直沿路径查询，当路径非法时，返回该层的最后一个合法节点。但根据对题目的分析之后，我发现需要返回最后一个合法的节点，也就是我一开始的做法的父亲节点。
```

**2. 错误地认为节点的id是自上而下递增的**

```
  我起初认为节点的id是自上而下递增出现的，因此最初我采用自底向上建树，错误地认为后建节点的孩子一定已经建立完毕。
  之后刘云昊同学提醒了我的错误认识，所以我改成递归初始化高度、大小和后缀最大高度，保证每次新建立节点的时候其孩子节点及其之后的兄弟节点都已经建立完毕。
```

### 三、时间和空间复杂度估算**

##### **1. 时间复杂度**

​		**建树**：对于规模为n的多叉树，基于递归策略，每个节点都访问（建立)一次。复杂度o(n)

​		**插入和删除**：寻找目标节点cost，逆序更新cost,改变物理前后继关系o(1)。共o(2cost)

​		**问询**：只需要沿路径找到节点，o(cost)

​		因此总时间复杂度为：
$$
T(n) = O(n+2k*cost + q*cost) = O(n+\sum_m cost_i)
$$

​		其中n为树规模，m为子树移动、问询次数的总和。

##### **2. 空间复杂度**

​		使用邻接链表存储多叉树，每个节点在多叉树中占o(1)的空间。同时维护了每个节点的父亲，o(n)的空间。总空间复杂度为：

$$
S(n) = O(2*n) = O(n)
$$

