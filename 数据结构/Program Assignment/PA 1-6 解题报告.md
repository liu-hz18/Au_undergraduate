# PA 1-4 解题报告

#### 刘泓尊  2018011446  计84

### 一、数据结构与算法构思

#### 1.思路来源

​		由于此文本编辑器中有大量的删除与插入操作，所以自然想到使用链表进行存储，又因为还包括前后节点的任意访问，所以应采用双向链表。为加快节点的访问速度并减少出错几率，我采用了数组存储链表的节点。

#### 2.参考资料

​		a.双向链表采用数组存储，此做法来自于本题的**"提示"**。

​		b.对于数组模拟双向链表**“头尾节点的处理”**，我参考了博客https://blog.csdn.net/qq_43490894/article/details/89474905的做法，将其单独存储。

​		c.对于数据反转的O(1)的延时更新操作，我是和课程**小助教“董博文”**简短讨论后得到了启发。

#### 3.算法思路

​		采用OOP思想，将Textditor的各个操作封装，具体的类方法如下：

​		**a.初始化**

​		在我的程序中，对象初始化便将输入的字符串存入链表，具体步骤为：str[i]存储链表的数据域，next[i]存储链表后继节点，prev[i]存储链表的前驱节点。为了减少麻烦，我**将头节点空出**，index设为0，并规定：**prev[0] = -1,next[0] = 1**.并以next[i] == -1来标记尾节点的出现。

​		对于光标的位置，我采用beforeCursor[0]和beforeCursor[1]分别标记当前左右光标前一个元素的**在str中的位置**，并以indexCursor[0]和indexCursor[1]表示左右光标**在“输出字符串”中的位置**，使得判断先后关系的过程变为O(1)的。

​		**b.区间反转**

​		在区间反转时可以发现，每次只有区间两端的节点先后关系发生了根本变化，对于区间内部的节点，只是将节点的prev[i]和next[i]进行了交换，因此我们可以在反转时只反转两端的先后关系，在之后，访问到区间内节点时，**检测该节点的前驱的后继是不是等于自己**，便可以判断是否需要反转prev 和 next。需要注意一些细节问题，交换两侧的节点，两端共需要6步操作。

​		**c.插入字母**

​		插入时，只需要寻找光标所指向节点，并标记该节点的后继节点，新建节点并将其插入即可。注意不要忘记将光标所指位置进行改变！！！当另一个光标在该光标右侧或者重合时，应当同时移动另一个光标！！！其中构建节点先后关系总共需要4步操作。最后应该改变光标的指向。

​		**d.删除字母**

​		与插入操作类似，每次只需要访问该光标所指节点，及其后继节点与后继的后继的节点，删除中间节点即可。注意在删除前，应先检查该点是不是需要进行**区间反转**，即将prev与next 的值交换。并注意将光标的指向进行改变。

​		**e.移动光标**

​		移动光标仅需要将当前光标指向移动到它的前驱或后继。注意在移动前，应先检查该点是不是需要进行**区间反转**，即将prev与next 的值交换。并注意将光标的指向进行改变。

​		**f.输出**		

​		输出时应该从头节点开始，next[0]作为字符串的第一个位置进行循环。注意在输出前，应先检查该点是不是需要进行**区间反转**，即将prev与next 的值交换。

### 二、过程中遇到的问题与解决

#### 1. 区间反转复杂度O(n)导致TLE

​		在最初的版本中，我区间反转操作是O(n)的，导致很多测试点超时。对于数据反转的O(1)的**延时更新**操作，我是和课程小助教“董博文”简短讨论后得到了启发。解决了本题的超时问题。

### 三、复杂度估计

#### 1.时间复杂度

​		由于使用了**双向链表+延时更新**操作，使得除了输出外，每一步的复杂度都是O(1)的，设进行的操作次数为n,总时间复杂度为：
$$
O(n)
$$

#### 2.空间复杂度    

​		在本题中，我使用了str[]存储节点数据，使用prev[] 和 next[]存储每个节点的前驱和后继，因此总空间复杂度为：
$$
O(n)
$$
