# **PA 3-4 解题报告**

##### 刘泓尊   2018011446   计84

### 一、数据结构与算法构思

#### 1. 前缀出现次数和

#### **1.1 思路来源**

​		根据本题提示，可以采用KMP算法中的next表。next表的含义是字符串前i个字符的子串Preifx[i]中，其子前缀与子后缀重合的最大长度。因此，next的数组与Prefix[i]中前缀的出现次数密切相关。

#### **1.2 获得的帮助**

​	1.next[0] = -1的方式参考了课堂讲义 13-C4

​	2.对next表的理解，来自于课堂和课程讲义

#### **1.3 思路**

**1.3.1 利用 next的传递路径和 计算结果 **

​		next表的含义是字符串前i个字符的子串Preifx[i]中，其子前缀与子后缀重合的最大长度。因此对于位置i，其next[i]为该处字符上一次出现的位置，next[next[i]]为再前一次出现的位置，直到迭代到next[next...]为第0个字符，此时迭代的次数就是该前缀出现的次数。

​		因此，对每个位置i,计算其next的迭代长度，将其进行求和就可以得到每个前缀出现的次数和。

**1.3.2 从O(n^2)到O(n)的优化**

​		构建完next表之后，如果从前向后扫描next表，会产生重复走的路径，即后面的next迭代顺序会覆盖前面的路径。因此可以考虑从后向前扫描：通过mark数组转移状态，记录每个位置被经过的次数，o(n)即可得到结果。即每次 mark[next[i]] += mark[i] + 1

### 二、时间和空间复杂度估算

##### **1. 时间复杂度**

​		获得next表的复杂度为O(n), 将所有next路径长度求出总和需要自后向前扫描，复杂度O(n).故时间复杂度为：
$$
T(n) = O(n)
$$

**2. 空间复杂度**

​			需要存储字符串本身，next表，以及状态转移数组mark，空间复杂度为O(n)

$$
S(n) = O(n)
$$

